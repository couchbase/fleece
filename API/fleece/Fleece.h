//
// Fleece.h
//
// Copyright (c) 2016 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#pragma once
#ifndef _FLEECE_H
#define _FLEECE_H

#include "FLSlice.h"
#include <stdio.h>

#ifdef __clang__
    #define FLNONNULL  __attribute__((nonnull))
#else
    #define FLNONNULL
#endif


#ifdef __cplusplus
extern "C" {
#endif

    // This is the C API! For the C++ API, see Fleece.hh.


    //////// BASIC TYPES

    /** \defgroup types    Basic data types
        @{ */

#ifndef FL_IMPL
    typedef const struct _FLValue* FLValue;         ///< A reference to a value of any type.
    typedef const struct _FLArray* FLArray;         ///< A reference to an array value.
    typedef const struct _FLDict*  FLDict;          ///< A reference to a dictionary (map) value.
    typedef struct _FLArray*       FLMutableArray;  ///< A reference to a mutable array.
    typedef struct _FLDict*        FLMutableDict;   ///< A reference to a mutable dictionary.
#endif


    /** Error codes returned from some API calls. */
    typedef enum {
        kFLNoError = 0,
        kFLMemoryError,        // Out of memory, or allocation failed
        kFLOutOfRange,         // Array index or iterator out of range
        kFLInvalidData,        // Bad input data (NaN, non-string key, etc.)
        kFLEncodeError,        // Structural error encoding (missing value, too many ends, etc.)
        kFLJSONError,          // Error parsing JSON
        kFLUnknownValue,       // Unparseable data in a Value (corrupt? Or from some distant future?)
        kFLInternalError,      // Something that shouldn't happen
        kFLNotFound,           // Key not found
        kFLSharedKeysStateError, // Misuse of shared keys (not in transaction, etc.)
        kFLPOSIXError,
        kFLUnsupported,         // Operation is unsupported
    } FLError;


    //////// DOCUMENT


    /** @} */
    /** \defgroup reading   Reading Fleece Data
         @{
        \name FLDoc
         @{
            An FLDoc points to (and often owns) Fleece-encoded data and provides access to its
            Fleece values.
     */

#ifndef FL_IMPL
    typedef struct _FLDoc*         FLDoc;           ///< A reference to a document.
    typedef struct _FLSharedKeys*  FLSharedKeys;    ///< A reference to a shared-keys mapping.
#endif

    /** Specifies whether not input data is trusted to be 100% valid Fleece. */
    typedef enum {
        /** Input data is not trusted to be valid, and will be fully validated by the API call. */
        kFLUntrusted,
        /** Input data is trusted to be valid. The API will perform only minimal validation when
            reading it. This is faster than kFLUntrusted, but should only be used if
            the data was generated by a trusted encoder and has not been altered or corrupted. For
            example, this can be used to parse Fleece data previously stored by your code in local
            storage.
            If invalid data is read by this call, subsequent calls to Value accessor functions can
            crash or return bogus results (including data from arbitrary memory locations.) */
        kFLTrusted
    } FLTrust;


    /** Creates an FLDoc from Fleece-encoded data. The resulting document does **not** copy
        or retain the input data, so the caller is in charge of ensuring that the data remains
        intact for as long as the FLDoc and any FLValues obtained from it exist.

        @note A safer way to create a doc, if you can spare the heap space, is to call FLSlice_Copy
        to copy the encoded data to an FLSliceResult, then call FLDoc_FromResultData. */
    FLDoc FLDoc_FromData(FLSlice data, FLTrust, FLSharedKeys, FLSlice externData);

    /** Creates an FLDoc from Fleece-encoded data that's been returned as a result from
        FLSlice_Copy or other API. The resulting document retains the data, so you don't need to
        worry about it remaining valid. */
    FLDoc FLDoc_FromResultData(FLSliceResult data, FLTrust, FLSharedKeys, FLSlice externData);

    /** Creates an FLDoc from JSON-encoded data. The data is first encoded into Fleece, and the
        Fleece data is kept by the doc; the input JSON data is no longer needed after this
        function returns. */
    FLDoc FLDoc_FromJSON(FLSlice json, FLError *outError);

    /** Releases a reference to an FLDoc. This must be called once to free an FLDoc you created. */
    void FLDoc_Release(FLDoc);

    /** Adds a reference to an FLDoc. This extends its lifespan until at least such time as you
        call FLRelease to remove the reference. */
    FLDoc FLDoc_Retain(FLDoc);

    /** Returns the encoded Fleece data backing the document. */
    FLSlice FLDoc_GetData(FLDoc);

    /** Returns the FLSliceResult data owned by the document, if any, else a null slice. */
    FLSliceResult FLDoc_GetAllocedData(FLDoc);

    /** Returns the root value in the FLDoc, usually an FLDict. */
    FLValue FLDoc_GetRoot(FLDoc);

    /** Returns the FLSharedKeys used by this FLDoc, as specified when it was created. */
    FLSharedKeys FLDoc_GetSharedKeys(FLDoc);

    /** Looks up the Doc containing the Value, or NULL if the Value was created without a Doc.
        Caller must release the FLDoc reference!! */
    FLDoc FLValue_FindDoc(FLValue);


    /** @} */
    /** \name Parsing And Converting Values Directly
     @{ */

    /** Returns a pointer to the root value in the encoded data, or NULL if validation failed.
        The FLValue, and all values found through it, are only valid as long as the encoded data
        remains intact and unchanged. */
    FLValue FLValue_FromData(FLSlice data, FLTrust);

    /** Directly converts JSON data to Fleece-encoded data.
        You can then call FLValue_FromData (in kFLTrusted mode) to get the root as a Value. */
    FLSliceResult FLData_ConvertJSON(FLSlice json, FLError *outError);

    /** Produces a human-readable dump of the Value encoded in the data.
        This is only useful if you already know, or want to learn, the encoding format. */
    FLStringResult FLData_Dump(FLSlice data);


    /** @} */
    /** @} */
    /** \defgroup json   Converting To JSON
     @{
        These are convenience functions that directly return JSON-encoded output.
        For more control over the encoding, use an FLEncoder. */

    /** Encodes a Fleece value as JSON (or a JSON fragment.)
        Any Data values will become base64-encoded JSON strings. */
    FLStringResult FLValue_ToJSON(FLValue);

    /** Encodes a Fleece value as JSON5, a more lenient variant of JSON that allows dictionary
        keys to be unquoted if they're alphanumeric. This tends to be more readable. */
    FLStringResult FLValue_ToJSON5(FLValue v);

    /** Most general Fleece to JSON converter. */
    FLStringResult FLValue_ToJSONX(FLValue v,
                                  bool json5,
                                  bool canonicalForm);

    /** Converts valid JSON5 to JSON. Among other things, it converts single quotes to double,
        adds missing quotes around dictionary keys, and adds missing trailing commas.
        If given _invalid_ JSON5, it will likely return an error but may just ouput comparably
        invalid JSON. */
    FLStringResult FLJSON5_ToJSON(FLString json5, FLError *error);

    /** \name Debugging Functions
        @{ */
    /** Debugging function that returns a C string of JSON. Does not free the string's memory! */
    const char* FLDump(FLValue);
    /** Debugging function that returns a C string of JSON. Does not free the string's memory! */
    const char* FLDumpData(FLSlice data);

    /** @} */


    //////// VALUE

    /** @} */
    /** \defgroup FLValue   Value Accessors
         @{
        The core Fleece data type is FLValue: a reference to a value in Fleece-encoded data.
        An FLValue can represent any JSON type (plus binary data).

        - Scalar data types -- numbers, booleans, null, strings, data -- can be accessed
          using individual functions of the form `FLValue_As...`; these return the scalar value,
          or a default zero/false/null value if the value is not of that type.
        - Collections -- arrays and dictionaries -- have their own "subclasses": FLArray and
          FLDict. These have the same pointer values as an FLValue but are not type-compatible
          in C. To coerce an FLValue to a collection type, call FLValue_AsArray or FLValue_AsDict.
          If the value is not of that type, NULL is returned. (FLArray and FLDict are documented
          fully in their own sections.)

        It's always safe to pass a NULL value to an accessor; that goes for FLDict and FLArray
        as well as FLValue. The result will be a default value of that type, e.g. false or 0
        or NULL, unless otherwise specified. */

    /** Types of Fleece values. Basically JSON, with the addition of Data (raw blob). */
    typedef enum {
        kFLUndefined = -1,  // Type of a NULL pointer, i.e. no such value, like JSON `undefined`
        kFLNull = 0,        // This is a non-NULL value, equivalent to a JSON 'null'
        kFLBoolean,
        kFLNumber,
        kFLString,
        kFLData,
        kFLArray,
        kFLDict
    } FLValueType;


    /** Returns the data type of an arbitrary Value.
        (If the parameter is a NULL pointer, returns `kFLUndefined`.) */
    FLValueType FLValue_GetType(FLValue);

    /** Returns true if the value is non-NULL and represents an integer. */
    bool FLValue_IsInteger(FLValue);

    /** Returns true if the value is non-NULL and represents an _unsigned_ integer that can only
        be represented natively as a `uint64_t`. In that case, you should not call `FLValueAsInt`
        because it will return an incorrect (negative) value; instead call `FLValueAsUnsigned`. */
    bool FLValue_IsUnsigned(FLValue);

    /** Returns true if the value is non-NULL and represents a 64-bit floating-point number. */
    bool FLValue_IsDouble(FLValue);

    /** Returns a value coerced to boolean. This will be true unless the value is NULL (undefined),
        null, false, or zero. */
    bool FLValue_AsBool(FLValue);

    /** Returns a value coerced to an integer. True and false are returned as 1 and 0, and
        floating-point numbers are rounded. All other types are returned as 0.
        @warning  Large 64-bit unsigned integers (2^63 and above) will come out wrong. You can
        check for these by calling `FLValueIsUnsigned`. */
    int64_t FLValue_AsInt(FLValue);

    /** Returns a value coerced to an unsigned integer.
        This is the same as `FLValueAsInt` except that it _can't_ handle negative numbers, but
        does correctly return large `uint64_t` values of 2^63 and up. */
    uint64_t FLValue_AsUnsigned(FLValue);

    /** Returns a value coerced to a 32-bit floating point number. */
    float FLValue_AsFloat(FLValue);

    /** Returns a value coerced to a 64-bit floating point number. */
    double FLValue_AsDouble(FLValue);

    /** Returns the exact contents of a string value, or null for all other types. */
    FLString FLValue_AsString(FLValue);

    /** Returns the exact contents of a data value, or null for all other types. */
    FLSlice FLValue_AsData(FLValue);

    /** If a FLValue represents an array, returns it cast to FLArray, else NULL. */
    FLArray FLValue_AsArray(FLValue);

    /** If a FLValue represents a dictionary, returns it as an FLDict, else NULL. */
    FLDict FLValue_AsDict(FLValue);

    /** Returns a string representation of any scalar value. Data values are returned in raw form.
        Arrays and dictionaries don't have a representation and will return NULL. */
    FLStringResult FLValue_ToString(FLValue);

    /** \name Ref-counting (mutable values only)
         @{ */

    /** If this value is mutable (and thus heap-based) its ref-count is incremented.
        Otherwise, this call does nothing. */
    FLValue FLValue_Retain(FLValue);

    /** If this value is mutable (and thus heap-based) its ref-count is decremented, and if it
        reaches zero the value is freed.
        If the value is not mutable, this call does nothing. */
    void FLValue_Release(FLValue);

    /** @} */

    //////// ARRAY


    /** @} */
    /** \defgroup FLArray   Arrays
        @{
        FLArray is a "subclass" of FLValue, representing values that are arrays. It's always OK to
        pass an FLArray to a function parameter expecting an FLValue, even though the compiler
        makes you use an explicit type-cast. It's safe to type-cast the other direction, from
        FLValue to FLArray, _only_ if you already know that the value is an array, e.g. by having
        called FLValue_GetType on it. But it's safer to call FLValue_AsArray instead, since it
        will return NULL if the value isn't an array.
     */

    /** Returns the number of items in an array, or 0 if the pointer is NULL. */
    uint32_t FLArray_Count(FLArray);

    /** Returns true if an array is empty (or NULL). Depending on the array's representation,
        this can be faster than `FLArray_Count(a) == 0` */
    bool FLArray_IsEmpty(FLArray);

    /** If the array is mutable, returns it cast to FLMutableArray, else NULL. */
    FLMutableArray FLArray_AsMutable(FLArray);

    /** Returns an value at an array index, or NULL if the index is out of range. */
    FLValue FLArray_Get(FLArray, uint32_t index);


    /** \name Array iteration
        @{
Iterating an array typically looks like this:

```
FLArrayIterator iter;
FLArrayIterator_Begin(theArray, &iter);
FLValue value;
while (NULL != (value = FLArrayIterator_GetValue(&iter))) {
  // ...
  FLArrayIterator_Next(&iter);
}
```
     */

    /** Opaque array iterator. Declare one on the stack and pass its address to
        `FLArrayIteratorBegin`. */
    typedef struct {
#if !DOXYGEN_PARSING
        void* _private1;
        uint32_t _private2;
        bool _private3;
        void* _private4;
#endif
    } FLArrayIterator;

    /** Initializes a FLArrayIterator struct to iterate over an array.
        Call FLArrayIteratorGetValue to get the first item, then FLArrayIteratorNext. */
    void FLArrayIterator_Begin(FLArray, FLArrayIterator* FLNONNULL);

    /** Returns the current value being iterated over. */
    FLValue FLArrayIterator_GetValue(const FLArrayIterator* FLNONNULL);

    /** Returns a value in the array at the given offset from the current value. */
    FLValue FLArrayIterator_GetValueAt(const FLArrayIterator* FLNONNULL, uint32_t offset);

    /** Returns the number of items remaining to be iterated, including the current one. */
    uint32_t FLArrayIterator_GetCount(const FLArrayIterator* FLNONNULL);

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLArrayIterator_Next(FLArrayIterator* FLNONNULL);

    /** @} */

    //////// MUTABLE ARRAY

    /** \name Mutable Arrays
         @{ */

    /** Creates a new mutable array that's a shallow, lazy copy of the source array.
        Its initial ref-count is 1, so a call to FLMutableArray_Free will free it.
        No items are copied up front: instead the new Array keeps a pointer to the source, and
        if it doesn't yet contain a value for a key, it look it up in the source.
        If the source array is NULL, an empty mutable Array is returned. */
    FLMutableArray FLArray_MutableCopy(FLArray);

    /** Creates a new empty mutable Array.
        Its initial ref-count is 1, so a call to FLMutableArray_Free will free it.  */
    FLMutableArray FLMutableArray_New(void);

    /** Increments the ref-count of a mutable Array. */
    static inline FLMutableArray FLMutableArray_Retain(FLMutableArray d) {
        return (FLMutableArray)FLValue_Retain((FLValue)d);
    }
    /** Decrements the refcount of (and possibly frees) a mutable Array. */
    static inline void FLMutableArray_Release(FLMutableArray d) {
        FLValue_Release((FLValue)d);
    }

    /** If the Array was created by FLArray_MutableCopy, returns the original source Array. */
    FLArray FLMutableArray_GetSource(FLMutableArray);

    /** Returns true if the Array has been changed from the source it was copied from. */
    bool FLMutableArray_IsChanged(FLMutableArray);

    /** Appends a JSON `null` value to an array. */
    void FLMutableArray_AppendNull(FLMutableArray);
    void FLMutableArray_AppendBool(FLMutableArray, bool);        ///< Appends a boolean.
    void FLMutableArray_AppendInt(FLMutableArray, int64_t);      ///< Appends an integer.
    void FLMutableArray_AppendUInt(FLMutableArray, uint64_t);    ///< Appends an unsigned integer.
    void FLMutableArray_AppendFloat(FLMutableArray, float);      ///< Appends a 32-bit float.
    void FLMutableArray_AppendDouble(FLMutableArray, double);    ///< Appends a 64-bit float.
    void FLMutableArray_AppendString(FLMutableArray, FLString);  ///< Appends a string.
    void FLMutableArray_AppendData(FLMutableArray, FLSlice);     ///< Appends a blob/data.
    void FLMutableArray_AppendValue(FLMutableArray, FLValue);    ///< Appends a Fleece value.

    /** Sets the value at an index to a JSON `null` value. */
    void FLMutableArray_SetNull(FLMutableArray, uint32_t index);
    /** Sets the value at an index to a boolean value. */
    void FLMutableArray_SetBool(FLMutableArray, uint32_t index, bool);
    /** Sets the value at an index to an integer. */
    void FLMutableArray_SetInt(FLMutableArray, uint32_t index, int64_t);
    /** Sets the value at an index to an unsigned integer. */
    void FLMutableArray_SetUInt(FLMutableArray, uint32_t index, uint64_t);
    /** Sets the value at an index to a 32-bit float value. */
    void FLMutableArray_SetFloat(FLMutableArray, uint32_t index, float);
    /** Sets the value at an index to a 64-bit float value. */
    void FLMutableArray_SetDouble(FLMutableArray, uint32_t index, double);
    /** Sets the value at an index to a string value. */
    void FLMutableArray_SetString(FLMutableArray, uint32_t index, FLString);
    /** Sets the value at an index to a blob/data value. */
    void FLMutableArray_SetData(FLMutableArray, uint32_t index, FLSlice);
    /** Sets the value at an index to a Fleece value. */
    void FLMutableArray_SetValue(FLMutableArray, uint32_t index, FLValue);

    /** Removes contiguous items from the array.
        @param array  The array to operate on.
        @param firstIndex  The zero-based index of the first item to remove.
        @param count  The number of items to remove. */
    void FLMutableArray_Remove(FLMutableArray array, uint32_t firstIndex, uint32_t count);

    /** Changes the size of an array.
        If the new size is larger, the array is padded with JSON `null` values.
        If it's smaller, values are removed from the end. */
    void FLMutableArray_Resize(FLMutableArray array, uint32_t size);

    /** Convenience function for getting an array-valued property in mutable form.
        - If the value for the key is not an array, returns NULL.
        - If the value is a mutable array, returns it.
        - If the value is an immutable array, this function makes a mutable copy, assigns the
          copy as the property value, and returns the copy. */
    FLMutableArray FLMutableArray_GetMutableArray(FLMutableArray, uint32_t index);

    /** Convenience function for getting an array-valued property in mutable form.
        - If the value for the key is not an array, returns NULL.
        - If the value is a mutable array, returns it.
        - If the value is an immutable array, this function makes a mutable copy, assigns the
          copy as the property value, and returns the copy. */
    FLMutableDict FLMutableArray_GetMutableDict(FLMutableArray, uint32_t index);

    /** @} */

    //////// DICT


    /** @} */
    /** \defgroup FLDict   Dictionaries
        @{ */

    /** Returns the number of items in a dictionary, or 0 if the pointer is NULL. */
    uint32_t FLDict_Count(FLDict);

    /** Returns true if a dictionary is empty (or NULL). Depending on the dictionary's
        representation, this can be faster than `FLDict_Count(a) == 0` */
    bool FLDict_IsEmpty(FLDict);

    /** If the dictionary is mutable, returns it cast to FLMutableDict, else NULL. */
    FLMutableDict FLDict_AsMutable(FLDict);

    /** Looks up a key in a dictionary, returning its value.
        Returns NULL if the value is not found or if the dictionary is NULL. */
    FLValue FLDict_Get(FLDict, FLSlice keyString);

    /** \name Dict iteration
         @{
Iterating a dictionary typically looks like this:

```
FLDictIterator iter;
FLDictIterator_Begin(theDict, &iter);
FLValue value;
while (NULL != (value = FLDictIterator_GetValue(&iter))) {
    FLString key = FLDictIterator_GetKeyString(&iter);
    // ...
    FLDictIterator_Next(&iter);
}
```
     */

    /** Opaque dictionary iterator. Declare one on the stack, and pass its address to
        FLDictIterator_Begin. */
    typedef struct {
#if !DOXYGEN_PARSING
        void* _private1;
        uint32_t _private2;
        bool _private3;
        void* _private4[4];
        int _private5;
#endif
    } FLDictIterator;

    /** Initializes a FLDictIterator struct to iterate over a dictionary.
        Call FLDictIterator_GetKey and FLDictIterator_GetValue to get the first item,
        then FLDictIterator_Next. */
    void FLDictIterator_Begin(FLDict, FLDictIterator* FLNONNULL);

    /** Returns the current key being iterated over. This Value will be a string or an integer. */
    FLValue FLDictIterator_GetKey(const FLDictIterator* FLNONNULL);

    /** Returns the current key's string value. */
    FLString FLDictIterator_GetKeyString(const FLDictIterator* FLNONNULL);

    /** Returns the current value being iterated over. */
    FLValue FLDictIterator_GetValue(const FLDictIterator* FLNONNULL);

    /** Returns the number of items remaining to be iterated, including the current one. */
    uint32_t FLDictIterator_GetCount(const FLDictIterator*  FLNONNULL);

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLDictIterator_Next(FLDictIterator* FLNONNULL);

    /** Cleans up after an iterator. Only needed if (a) the dictionary is a delta, and
        (b) you stop iterating before the end (i.e. before FLDictIterator_Next returns false.) */
    void FLDictIterator_End(FLDictIterator* FLNONNULL);

    /** @} */
    /** \name Optimized Keys
        @{ */

    /** Opaque key for a dictionary. You are responsible for creating space for these; they can
        go on the stack, on the heap, inside other objects, anywhere. 
        Be aware that the lookup operations that use these will write into the struct to store
        "hints" that speed up future searches. */
    typedef struct {
#if !DOXYGEN_PARSING
        FLSlice _private1;
        void* _private2;
        uint32_t _private3, private4;
        bool private5;
#endif
    } FLDictKey;

    /** Initializes an FLDictKey struct with a key string.
        @warning  The input string's memory MUST remain valid for as long as the FLDictKey is in
        use! (The FLDictKey stores a pointer to the string, but does not copy it.)
        @param string  The key string (UTF-8).
        @return  An initialized FLDictKey struct. */
    FLDictKey FLDictKey_Init(FLSlice string);

    /** Returns the string value of the key (which it was initialized with.) */
    FLString FLDictKey_GetString(const FLDictKey * FLNONNULL);

    /** Looks up a key in a dictionary using an FLDictKey. If the key is found, "hint" data will
        be stored inside the FLDictKey that will speed up subsequent lookups. */
    FLValue FLDict_GetWithKey(FLDict, FLDictKey* FLNONNULL);


    //////// MUTABLE DICT

    /** @} */
    /** \name Mutable dictionaries
         @{ */

    /** Creates a new mutable Dict that's a shallow, lazy copy of the source Dict.
        Its initial ref-count is 1, so a call to FLMutableDict_Free will free it.
        No items are copied up front: instead the new Dict keeps a pointer to the source, and
        if it doesn't yet contain a value for a key, it look it up in the source.
        If the source dict is NULL, an empty mutable Dict is returned. */
    FLMutableDict FLDict_MutableCopy(FLDict source);

    /** Creates a new empty mutable Dict.
        Its initial ref-count is 1, so a call to FLMutableDict_Free will free it.  */
    FLMutableDict FLMutableDict_New(void);

    /** Increments the ref-count of a mutable Dict. */
    static inline FLMutableDict FLMutableDict_Retain(FLMutableDict d) {
        return (FLMutableDict)FLValue_Retain((FLValue)d);
    }

    /** Decrements the refcount of (and possibly frees) a mutable Dict. */
    static inline void FLMutableDict_Release(FLMutableDict d) {
        FLValue_Release((FLValue)d);
    }

    /** If the Dict was created by FLDict_MutableCopy, returns the original source Dict. */
    FLDict FLMutableDict_GetSource(FLMutableDict);

    /** Returns true if the Dict has been changed from the source it was copied from. */
    bool FLMutableDict_IsChanged(FLMutableDict);

    /** Sets the value of a key to a JSON `null` value (which is not the same as removing the key!) */
    void FLMutableDict_SetNull(FLMutableDict, FLString key);
    /** Sets the value of a key to a boolean value. */
    void FLMutableDict_SetBool(FLMutableDict, FLString key, bool);
    /** Sets the value of a key to an integer value. */
    void FLMutableDict_SetInt(FLMutableDict, FLString key, int64_t);
    /** Sets the value of a key to an unsigned integer value. */
    void FLMutableDict_SetUInt(FLMutableDict, FLString key, uint64_t);
    /** Sets the value of a key to a 32-bit float value. */
    void FLMutableDict_SetFloat(FLMutableDict, FLString key, float);
    /** Sets the value of a key to a 64-bit float value. */
    void FLMutableDict_SetDouble(FLMutableDict, FLString key, double);
    /** Sets the value of a key to a string value. */
    void FLMutableDict_SetString(FLMutableDict, FLString key, FLString);
    /** Sets the value of a key to a data (blob) value. */
    void FLMutableDict_SetData(FLMutableDict, FLString key, FLSlice);
    /** Sets the value of a key to an existing Fleece value. */
    void FLMutableDict_SetValue(FLMutableDict, FLString key, FLValue);

    /** Removes the value for a key. */
    void FLMutableDict_Remove(FLMutableDict, FLString key);

    /** Removes all keys and values. */
    void FLMutableDict_RemoveAll(FLMutableDict);

    /** Convenience function for getting an array-valued property in mutable form.
        - If the value for the key is not an array, returns NULL.
        - If the value is a mutable array, returns it.
        - If the value is an immutable array, this function makes a mutable copy, assigns the
          copy as the property value, and returns the copy. */
    FLMutableArray FLMutableDict_GetMutableArray(FLMutableDict, FLString key);

    /** Convenience function for getting a dict-valued property in mutable form.
        - If the value for the key is not a dict, returns NULL.
        - If the value is a mutable dict, returns it.
        - If the value is an immutable dict, this function makes a mutable copy, assigns the
          copy as the property value, and returns the copy. */
    FLMutableDict FLMutableDict_GetMutableDict(FLMutableDict, FLString key);

    /** @} */


    //////// DEEP ITERATOR


    /** @} */
    /** \defgroup FLDeepIterator   Deep Iterator
        @{
        A deep iterator traverses every value contained in a dictionary, in depth-first order.
        You can skip any nested collection by calling FLDeepIterator_SkipChildren. */

#ifndef FL_IMPL
    typedef struct _FLDeepIterator* FLDeepIterator; ///< A reference to a deep iterator.
#endif

    /** Creates a FLDeepIterator to iterate over a dictionary.
        Call FLDeepIterator_GetKey and FLDeepIterator_GetValue to get the first item,
        then FLDeepIterator_Next. */
    FLDeepIterator FLDeepIterator_New(FLValue);

    void FLDeepIterator_Free(FLDeepIterator);

    /** Returns the current value being iterated over. or NULL at the end of iteration. */
    FLValue FLDeepIterator_GetValue(FLDeepIterator FLNONNULL);

    /** Returns the key of the current value, or an empty slice if not in a dictionary. */
    FLSlice FLDeepIterator_GetKey(FLDeepIterator FLNONNULL);

    /** Returns the array index of the current value, or 0 if not in an array. */
    uint32_t FLDeepIterator_GetIndex(FLDeepIterator FLNONNULL);

    /** Returns the current depth in the hierarchy, starting at 1 for the top-level children. */
    size_t FLDeepIterator_GetDepth(FLDeepIterator FLNONNULL);

    /** Tells the iterator to skip the children of the current value. */
    void FLDeepIterator_SkipChildren(FLDeepIterator FLNONNULL);

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLDeepIterator_Next(FLDeepIterator FLNONNULL);

    typedef struct {
        FLSlice key;        ///< Dict key, or kFLSliceNull if none
        uint32_t index;     ///< Array index, only if there's no key
    } FLPathComponent;

    /** Returns the path as an array of FLPathComponents. */
    void FLDeepIterator_GetPath(FLDeepIterator FLNONNULL,
                                FLPathComponent* * FLNONNULL outPath,
                                size_t* FLNONNULL outDepth);

    /** Returns the current path in JavaScript format. */
    FLSliceResult FLDeepIterator_GetPathString(FLDeepIterator FLNONNULL);

    /** Returns the current path in JSONPointer format (RFC 6901). */
    FLSliceResult FLDeepIterator_GetJSONPointer(FLDeepIterator FLNONNULL);


    //////// PATH


    /** @} */
    /** \defgroup FLKeyPath   Paths
        @{
     An FLKeyPath Describes a location in a Fleece object tree, as a path from the root that follows
     dictionary properties and array elements.
     It's similar to a JSONPointer or an Objective-C KeyPath, but simpler (so far.)
     The path is compiled into an efficient form that can be traversed quickly.

     It looks like `foo.bar[2][-3].baz` -- that is, properties prefixed with a `.`, and array
     indexes in brackets. (Negative indexes count from the end of the array.)

     A leading JSONPath-like `$.` is allowed but ignored.

     A '\' can be used to escape a special character ('.', '[' or '$') at the start of a
     property name (but not yet in the middle of a name.)
     */

#ifndef FL_IMPL
    typedef struct _FLKeyPath*     FLKeyPath;       ///< A reference to a key path.
#endif

    /** Creates a new FLKeyPath object by compiling a path specifier string. */
    FLKeyPath FLKeyPath_New(FLSlice specifier, FLError *error);

    /** Frees a compiled FLKeyPath object. (It's ok to pass NULL.) */
    void FLKeyPath_Free(FLKeyPath);

    /** Evaluates a compiled key-path for a given Fleece root object. */
    FLValue FLKeyPath_Eval(FLKeyPath FLNONNULL, FLValue root FLNONNULL);

    /** Evaluates a key-path from a specifier string, for a given Fleece root object.
        If you only need to evaluate the path once, this is a bit faster than creating an
        FLKeyPath object, evaluating, then freeing it. */
    FLValue FLKeyPath_EvalOnce(FLSlice specifier, FLValue root FLNONNULL, FLError *error);


    //////// SHARED KEYS


    /** @} */
    /** \defgroup FLSharedKeys   Shared Keys
        @{ */

    FLSharedKeys FLSharedKeys_Create(void);
    FLSharedKeys FLSharedKeys_Retain(FLSharedKeys);
    void FLSharedKeys_Release(FLSharedKeys);
    FLSharedKeys FLSharedKeys_CreateFromStateData(FLSlice);
    FLSliceResult FLSharedKeys_GetStateData(FLSharedKeys FLNONNULL);
    int FLSharedKeys_Encode(FLSharedKeys FLNONNULL, FLString, bool add);
    FLString FLSharedKeys_Decode(FLSharedKeys FLNONNULL, int key);


    //////// ENCODER


    /** @} */
    /** \defgroup FLEncoder   Encoder
        @{
        An FLEncoder generates encoded Fleece or JSON data. It's sort of a structured output stream,
        with nesting. There are functions for writing every type of scalar value, and for beginning
        and ending collections. To write a collection you begin it, write its values, then end it.
        (Of course a value in a collection can itself be another collection.) When writing a
        dictionary, you have to call writeKey before writing each value.
     */

#ifndef FL_IMPL
    typedef struct _FLEncoder*     FLEncoder;       ///< A reference to an encoder.
#endif

    /** \name Setup and configuration
         @{ */

    /** Output formats a FLEncoder can generate. */
    typedef enum {
        kFLEncodeFleece,    ///< Fleece encoding
        kFLEncodeJSON,      ///< JSON encoding
        kFLEncodeJSON5      ///< [JSON5](http://json5.org), an extension of JSON with a more readable syntax
    } FLEncoderFormat;


    /** Creates a new encoder, for generating Fleece data. Call FLEncoder_Free when done. */
    FLEncoder FLEncoder_New(void);

    /** Creates a new encoder, allowing some options to be customized.
        @param format  The output format to generate (Fleece, JSON, or JSON5.)
        @param reserveSize  The number of bytes to preallocate for the output. (Default is 256)
        @param uniqueStrings  (Fleece only) If true, string values that appear multiple times will be written
            as a single shared value. This saves space but makes encoding slightly slower.
            You should only turn this off if you know you're going to be writing large numbers
            of non-repeated strings. Note also that the `cachePointers` option of FLDictKey
            will not work if `uniqueStrings` is off. (Default is true) */
    FLEncoder FLEncoder_NewWithOptions(FLEncoderFormat format,
                                       size_t reserveSize,
                                       bool uniqueStrings);

    /** Creates a new Fleece encoder that writes to a file, not to memory. */
    FLEncoder FLEncoder_NewWritingToFile(FILE* FLNONNULL, bool uniqueStrings);

    /** Frees the space used by an encoder. */
    void FLEncoder_Free(FLEncoder);

    /** Tells the encoder to use a shared-keys mapping when encoding dictionary keys. */
    void FLEncoder_SetSharedKeys(FLEncoder FLNONNULL, FLSharedKeys);

    /** Associates an arbitrary user-defined value with the encoder. */
    void FLEncoder_SetExtraInfo(FLEncoder FLNONNULL, void *info);

    /** Returns the user-defined value associated with the encoder; NULL by default. */
    void* FLEncoder_GetExtraInfo(FLEncoder FLNONNULL);


    /** Tells the encoder to logically append to the given Fleece document, rather than making a
        standalone document. Any calls to FLEncoder_WriteValue() where the value points inside the
        base data will write a pointer back to the original value.
        The resulting data returned by FLEncoder_FinishDoc() will *NOT* be standalone; it can only
        be used by first appending it to the base data.
        @param e  The FLEncoder affected.
        @param base  The base document to create an amendment of.
        @param reuseStrings  If true, then writing a string that already exists in the base will
                    just create a pointer back to the original. But the encoder has to scan the
                    base for strings first.
        @param externPointers  If true, pointers into the base will be marked with the `extern`
                    flag. This allows them to be resolved using the `FLResolver_Begin` function,
                    so that when the delta is used the base document can be anywhere in memory,
                    not just immediately preceding the delta document. */
    void FLEncoder_Amend(FLEncoder e FLNONNULL, FLSlice base,
                         bool reuseStrings, bool externPointers);

    /** Returns the `base` value passed to FLEncoder_Amend. */
    FLSlice FLEncoder_GetBase(FLEncoder FLNONNULL);

    /** Tells the encoder not to write the two-byte Fleece trailer at the end of the data.
        This is only useful for certain special purposes. */
    void FLEncoder_SuppressTrailer(FLEncoder FLNONNULL);

    /** Resets the state of an encoder without freeing it. It can then be reused to encode
        another value. */
    void FLEncoder_Reset(FLEncoder FLNONNULL);

    /** Returns the number of bytes encoded so far. */
    size_t FLEncoder_BytesWritten(FLEncoder FLNONNULL);

    /** Returns the byte offset in the encoded data where the next value will be written.
        (Due to internal buffering, this is not the same as FLEncoder_BytesWritten.) */
    size_t FLEncoder_GetNextWritePos(FLEncoder FLNONNULL);

    /** @} */
    /** \name Writing to the encoder
         @{
        @note The functions that write to the encoder do not return error codes, just a 'false'
        result on error. The actual error is attached to the encoder and can be accessed by calling
        FLEncoder_GetError or FLEncoder_End.

        After an error occurs, the encoder will ignore all subsequent writes. */

    /** Writes a `null` value to an encoder. (This is an explicitly-stored null, like the JSON
        `null`, not the "undefined" value represented by a NULL FLValue pointer.) */
    bool FLEncoder_WriteNull(FLEncoder FLNONNULL);

    /** Writes a boolean value (true or false) to an encoder. */
    bool FLEncoder_WriteBool(FLEncoder FLNONNULL, bool);

    /** Writes an integer to an encoder. The parameter is typed as `int64_t` but you can pass any
        integral type (signed or unsigned) except for huge `uint64_t`s.
        The number will be written in a compact form that uses only as many bytes as necessary. */
    bool FLEncoder_WriteInt(FLEncoder FLNONNULL, int64_t);

    /** Writes an unsigned integer to an encoder. This function is only really necessary for huge
        64-bit integers greater than or equal to 2^63, which can't be represented as int64_t. */
    bool FLEncoder_WriteUInt(FLEncoder FLNONNULL, uint64_t);

    /** Writes a 32-bit floating point number to an encoder.
        @note As an implementation detail, if the number has no fractional part and can be
        represented exactly as an integer, it'll be encoded as an integer to save space. This is
        transparent to the reader, since if it requests the value as a float it'll be returned
        as floating-point. */
    bool FLEncoder_WriteFloat(FLEncoder FLNONNULL, float);

    /** Writes a 64-bit floating point number to an encoder.
        @note As an implementation detail, the number may be encoded as a 32-bit float or even
        as an integer, if this can be done without losing precision. For example, 123.0 will be
        written as an integer, and 123.75 as a float.) */
    bool FLEncoder_WriteDouble(FLEncoder FLNONNULL, double);

    /** Writes a string to an encoder. The string must be UTF-8-encoded and must not contain any
        zero bytes.
        @warning Do _not_ use this to write a dictionary key; use FLEncoder_WriteKey instead. */
    bool FLEncoder_WriteString(FLEncoder FLNONNULL, FLString);

    /** Writes a binary data value (a blob) to an encoder. This can contain absolutely anything
        including null bytes.
        If the encoder is generating JSON, the blob will be written as a base64-encoded string. */
    bool FLEncoder_WriteData(FLEncoder FLNONNULL, FLSlice);

    /** Writes raw data directly to the encoded output.
        (This is not the same as FLEncoder_WriteData, which safely encodes a blob.)
        @warning **Do not call this** unless you really know what you're doing ...
        it's quite unsafe, and only used for certain advanced purposes. */
    bool FLEncoder_WriteRaw(FLEncoder FLNONNULL, FLSlice);


    /** Begins writing an array value to an encoder. This pushes a new state where each
        subsequent value written becomes an array item, until FLEncoder_EndArray is called.
        @param reserveCount  Number of array elements to reserve space for. If you know the size
            of the array, providing it here speeds up encoding slightly. If you don't know,
            just use zero. */
    bool FLEncoder_BeginArray(FLEncoder FLNONNULL, size_t reserveCount);

    /** Ends writing an array value; pops back the previous encoding state. */
    bool FLEncoder_EndArray(FLEncoder FLNONNULL);


    /** Begins writing a dictionary value to an encoder. This pushes a new state where each
        subsequent key and value written are added to the dictionary, until FLEncoder_EndDict is
        called.
        Before adding each value, you must call FLEncoder_WriteKey (_not_ FLEncoder_WriteString!),
        to write the dictionary key.
        @param reserveCount  Number of dictionary items to reserve space for. If you know the size
            of the dictionary, providing it here speeds up encoding slightly. If you don't know,
            just use zero. */
    bool FLEncoder_BeginDict(FLEncoder FLNONNULL, size_t reserveCount);

    /** Specifies the key for the next value to be written to the current dictionary. */
    bool FLEncoder_WriteKey(FLEncoder FLNONNULL, FLString);

    /** Ends writing a dictionary value; pops back the previous encoding state. */
    bool FLEncoder_EndDict(FLEncoder FLNONNULL);


    /** Writes a Fleece Value to an Encoder. */
    bool FLEncoder_WriteValue(FLEncoder FLNONNULL, FLValue FLNONNULL);


    /** Parses JSON data and writes the object(s) to the encoder. (This acts as a single write,
        like WriteInt; it's just that the value written is likely to be an entire dictionary of
        array.) */
    bool FLEncoder_ConvertJSON(FLEncoder FLNONNULL, FLSlice json);

    /** @} */
    /** \name Finishing up
         @{ */

    /** Finishes encoding the current item, and returns its offset in the output data. */
    size_t FLEncoder_FinishItem(FLEncoder FLNONNULL);

    /** Ends encoding; if there has been no error, it returns the encoded Fleece data packaged in
        an FLDoc. (This function does not support JSON encoding.)
        This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next. */
    FLDoc FLEncoder_FinishDoc(FLEncoder FLNONNULL, FLError*);

    /** Ends encoding; if there has been no error, it returns the encoded data, else null.
        This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next. */
    FLSliceResult FLEncoder_Finish(FLEncoder e, FLError *outError);

    /** @} */
    /** \name Error handling
         @{ */

    /** Returns the error code of an encoder, or NoError (0) if there's no error. */
    FLError FLEncoder_GetError(FLEncoder FLNONNULL);

    /** Returns the error message of an encoder, or NULL if there's no error. */
    const char* FLEncoder_GetErrorMessage(FLEncoder FLNONNULL);

    /** @} */
    /** @} */


    //////// JSON DELTA COMPRESSION


    /** @} */
    /** \defgroup delta   Delta Compression
     @{
        These functions implement a fairly-efficient "delta" encoding that encapsulates the changes
        needed to transform one Fleece value into another. The delta is expressed in JSON form.

        A delta can be stored or transmitted
        as an efficient way to produce the second value, when the first is already present. Deltas
        are frequently used in version-control systems and efficient network protocols.
     */

    /** Returns JSON that encodes the changes to turn the value `old` into `nuu`;
        or if the values are equal, returns a null slice.
        (The format is documented in Fleece.md, but you should treat it as a black box.)
        @param old  A value that's typically the old/original state of some data.
        @param nuu  A value that's typically the new/changed state of the `old` data.
        @return  JSON data representing the changes from `old` to `nuu`. */
    FLSliceResult FLCreateJSONDelta(FLValue old, FLValue nuu);

    /** Writes JSON that describes the changes to turn the value `old` into `nuu`.
        If the values are equal, writes nothing and returns false.
        (The format is documented in Fleece.md, but you should treat it as a black box.)
        @param old  A value that's typically the old/original state of some data.
        @param nuu  A value that's typically the new/changed state of the `old` data.
        @param jsonEncoder  An encoder to write the JSON to. Must have been created using
                `FLEncoder_NewWithOptions`, with JSON or JSON5 format.
        @return  True if a delta was encoded, or false if the values are equal. */
    bool FLEncodeJSONDelta(FLValue old, FLValue nuu, FLEncoder FLNONNULL jsonEncoder);


    /** Applies the JSON data created by `CreateJSONDelta` to the value `old`, which must be equal
        to the `old` value originally passed to `FLCreateJSONDelta`, and returns a Fleece document
        equal to the original `nuu` value.
        @param old  A value that's typically the old/original state of some data. This must be
                    equal to the `old` value used when creating the `jsonDelta`.
        @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
        @param error  On failure, error information will be stored where this points, if non-null.
        @return  The corresponding `nuu` value, encoded as Fleece, or null if an error occurred. */
    FLSliceResult FLApplyJSONDelta(FLValue old,
                                   FLSlice jsonDelta,
                                   FLError *error);

    /** Applies the (parsed) JSON data created by `CreateJSONDelta` to the value `old`, which must be
        equal to the `old` value originally passed to `FLCreateJSONDelta`, and writes the corresponding
        `nuu` value to the encoder.
        @param old  A value that's typically the old/original state of some data. This must be
                    equal to the `old` value used when creating the `jsonDelta`.
        @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
        @param encoder  A Fleece encoder to write the decoded `nuu` value to. (JSON encoding is not
                    supported.)
        @return  True on success, false on error; call `FLEncoder_GetError` for details. */
    bool FLEncodeApplyingJSONDelta(FLValue old,
                                   FLValue FLNONNULL jsonDelta,
                                   FLEncoder encoder);

    
    /** @} */

#ifdef __cplusplus
}
#endif


#ifdef __OBJC__
// When compiling as Objective-C, include CoreFoundation / Objective-C utilities:
#include "Fleece+CoreFoundation.h"
#endif

#endif // _FLEECE_H
