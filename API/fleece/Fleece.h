//
// Fleece.h
//
// Copyright (c) 2016 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#pragma once
#ifndef _FLEECE_H
#define _FLEECE_H

#include "FLSlice.h"
#include <stdio.h>

#ifdef __clang__
    #define FLNONNULL  __attribute__((nonnull))
#else
    #define FLNONNULL
#endif


#ifdef __cplusplus
extern "C" {
#endif

    // This is the C API! For the C++ API, see Fleece.hh.


    //////// BASIC TYPES

    /** \defgroup types    Basic data types
        @{ */

#ifndef FL_IMPL
    typedef const struct _FLValue* FLValue;         ///< A reference to a value of any type.
    typedef const struct _FLArray* FLArray;         ///< A reference to an array value.
    typedef const struct _FLDict*  FLDict;          ///< A reference to a dictionary (map) value.
    typedef struct _FLSlot*        FLSlot;          ///< A reference to a mutable array/dict item
    typedef struct _FLArray*       FLMutableArray;  ///< A reference to a mutable array.
    typedef struct _FLDict*        FLMutableDict;   ///< A reference to a mutable dictionary.
#endif


    /** Error codes returned from some API calls. */
    typedef enum {
        kFLNoError = 0,
        kFLMemoryError,        // Out of memory, or allocation failed
        kFLOutOfRange,         // Array index or iterator out of range
        kFLInvalidData,        // Bad input data (NaN, non-string key, etc.)
        kFLEncodeError,        // Structural error encoding (missing value, too many ends, etc.)
        kFLJSONError,          // Error parsing JSON
        kFLUnknownValue,       // Unparseable data in a Value (corrupt? Or from some distant future?)
        kFLInternalError,      // Something that shouldn't happen
        kFLNotFound,           // Key not found
        kFLSharedKeysStateError, // Misuse of shared keys (not in transaction, etc.)
        kFLPOSIXError,
        kFLUnsupported,         // Operation is unsupported
    } FLError;


    //////// DOCUMENT


    /** @} */
    /** \defgroup reading   Reading Fleece Data
         @{
        \name FLDoc
         @{
            An FLDoc points to (and often owns) Fleece-encoded data and provides access to its
            Fleece values.
     */

#ifndef FL_IMPL
    typedef struct _FLDoc*         FLDoc;           ///< A reference to a document.
    typedef struct _FLSharedKeys*  FLSharedKeys;    ///< A reference to a shared-keys mapping.
#endif

    /** Specifies whether not input data is trusted to be 100% valid Fleece. */
    typedef enum {
        /** Input data is not trusted to be valid, and will be fully validated by the API call. */
        kFLUntrusted,
        /** Input data is trusted to be valid. The API will perform only minimal validation when
            reading it. This is faster than kFLUntrusted, but should only be used if
            the data was generated by a trusted encoder and has not been altered or corrupted. For
            example, this can be used to parse Fleece data previously stored by your code in local
            storage.
            If invalid data is read by this call, subsequent calls to Value accessor functions can
            crash or return bogus results (including data from arbitrary memory locations.) */
        kFLTrusted
    } FLTrust;


    /** Creates an FLDoc from Fleece-encoded data that's been returned as a result from
        FLSlice_Copy or other API. The resulting document retains the data, so you don't need to
        worry about it remaining valid. */
    FLDoc FLDoc_FromResultData(FLSliceResult data, FLTrust, FLSharedKeys, FLSlice externData) FLAPI;

    /** Creates an FLDoc from JSON-encoded data. The data is first encoded into Fleece, and the
        Fleece data is kept by the doc; the input JSON data is no longer needed after this
        function returns. */
    FLDoc FLDoc_FromJSON(FLSlice json, FLError *outError) FLAPI;

    /** Releases a reference to an FLDoc. This must be called once to free an FLDoc you created. */
    void FLDoc_Release(FLDoc) FLAPI;

    /** Adds a reference to an FLDoc. This extends its lifespan until at least such time as you
        call FLRelease to remove the reference. */
    FLDoc FLDoc_Retain(FLDoc) FLAPI;

    /** Returns the encoded Fleece data backing the document. */
    FLSlice FLDoc_GetData(FLDoc) FLAPI PURE;

    /** Returns the FLSliceResult data owned by the document, if any, else a null slice. */
    FLSliceResult FLDoc_GetAllocedData(FLDoc) FLAPI PURE;

    /** Returns the root value in the FLDoc, usually an FLDict. */
    FLValue FLDoc_GetRoot(FLDoc) FLAPI PURE;

    /** Returns the FLSharedKeys used by this FLDoc, as specified when it was created. */
    FLSharedKeys FLDoc_GetSharedKeys(FLDoc) FLAPI PURE;

    /** Looks up the Doc containing the Value, or NULL if the Value was created without a Doc.
        Caller must release the FLDoc reference!! */
    FLDoc FLValue_FindDoc(FLValue) FLAPI PURE;


    /** @} */
    /** \name Parsing And Converting Values Directly
     @{ */

    /** Returns a pointer to the root value in the encoded data, or NULL if validation failed.
        The FLValue, and all values found through it, are only valid as long as the encoded data
        remains intact and unchanged. */
    FLValue FLValue_FromData(FLSlice data, FLTrust) FLAPI PURE;

    /** Directly converts JSON data to Fleece-encoded data.
        You can then call FLValue_FromData (in kFLTrusted mode) to get the root as a Value. */
    FLSliceResult FLData_ConvertJSON(FLSlice json, FLError *outError) FLAPI;

    /** Produces a human-readable dump of the Value encoded in the data.
        This is only useful if you already know, or want to learn, the encoding format. */
    FLStringResult FLData_Dump(FLSlice data) FLAPI;


    /** @} */
    /** @} */
    /** \defgroup json   Converting To JSON
     @{
        These are convenience functions that directly return JSON-encoded output.
        For more control over the encoding, use an FLEncoder. */

    /** Encodes a Fleece value as JSON (or a JSON fragment.)
        Any Data values will become base64-encoded JSON strings. */
    FLStringResult FLValue_ToJSON(FLValue) FLAPI;

    /** Encodes a Fleece value as JSON5, a more lenient variant of JSON that allows dictionary
        keys to be unquoted if they're alphanumeric. This tends to be more readable. */
    FLStringResult FLValue_ToJSON5(FLValue v) FLAPI;

    /** Most general Fleece to JSON converter. */
    FLStringResult FLValue_ToJSONX(FLValue v,
                                  bool json5,
                                  bool canonicalForm) FLAPI;

    /** Converts valid JSON5 <https://json5.org> to JSON. Among other things, it converts single
        quotes to double, adds missing quotes around dictionary keys, removes trailing commas,
        and removes comments.
        @note If given invalid JSON5, it will _usually_ return an error, but may just ouput
              comparably invalid JSON, in which case the caller's subsequent JSON parsing will
              detect the error. The types of errors it overlooks tend to be subtleties of string
              or number encoding.
        @param json5  The JSON5 to parse
        @param outErrorMessage  On failure, the error message will be stored here (if not NULL.)
                        As this is a \ref FLStringResult, you will be responsible for freeing it.
        @param outErrorPos  On a parse error, the byte offset in the input where the error occurred
                        will be stored here (if it's not NULL.)
        @param outError  On failure, the error code will be stored here (if it's not NULL.)
        @return  The converted JSON. */
    FLStringResult FLJSON5_ToJSON(FLString json5,
                                  FLStringResult *outErrorMessage,
                                  size_t *outErrorPos,
                                  FLError *outError) FLAPI;

    /** \name Debugging Functions
        @{ */
    /** Debugging function that returns a C string of JSON. Does not free the string's memory! */
    const char* FLDump(FLValue) FLAPI;
    /** Debugging function that returns a C string of JSON. Does not free the string's memory! */
    const char* FLDumpData(FLSlice data) FLAPI;

    /** @} */


    //////// VALUE


    /** @} */
    /** \defgroup FLValue   Value Accessors
         @{
        The core Fleece data type is FLValue: a reference to a value in Fleece-encoded data.
        An FLValue can represent any JSON type (plus binary data).

        - Scalar data types -- numbers, booleans, null, strings, data -- can be accessed
          using individual functions of the form `FLValue_As...`; these return the scalar value,
          or a default zero/false/null value if the value is not of that type.
        - Collections -- arrays and dictionaries -- have their own "subclasses": FLArray and
          FLDict. These have the same pointer values as an FLValue but are not type-compatible
          in C. To coerce an FLValue to a collection type, call FLValue_AsArray or FLValue_AsDict.
          If the value is not of that type, NULL is returned. (FLArray and FLDict are documented
          fully in their own sections.)

        It's always safe to pass a NULL value to an accessor; that goes for FLDict and FLArray
        as well as FLValue. The result will be a default value of that type, e.g. false or 0
        or NULL, unless otherwise specified. */

    /** Types of Fleece values. Basically JSON, with the addition of Data (raw blob). */
    typedef enum {
        kFLUndefined = -1,  ///< Type of a NULL pointer, i.e. no such value, like JSON `undefined`. Also the type of a value created by FLEncoder_WriteUndefined().
        kFLNull = 0,        ///< Equivalent to a JSON 'null'
        kFLBoolean,         ///< A `true` or `false` value
        kFLNumber,          ///< A numeric value, either integer or floating-point
        kFLString,          ///< A string
        kFLData,            ///< Binary data (no JSON equivalent)
        kFLArray,           ///< An array of values
        kFLDict             ///< A mapping of strings to values
    } FLValueType;


    /** A timestamp, expressed as milliseconds since the Unix epoch (1-1-1970 midnight UTC.) */
    typedef int64_t FLTimestamp;

    /** A value representing a missing timestamp; returned when a date cannot be parsed. */
    #define FLTimestampNone INT64_MIN


    /** Returns the data type of an arbitrary Value.
        (If the parameter is a NULL pointer, returns `kFLUndefined`.) */
    FLValueType FLValue_GetType(FLValue) FLAPI PURE;

    /** Returns true if the value is non-NULL and represents an integer. */
    bool FLValue_IsInteger(FLValue) FLAPI PURE;

    /** Returns true if the value is non-NULL and represents an integer >= 2^63. Such a value can't
        be represented in C as an `int64_t`, only a `uint64_t`, so you should access it by calling
        `FLValueAsUnsigned`, _not_ FLValueAsInt, which would return  an incorrect (negative)
        value. */
    bool FLValue_IsUnsigned(FLValue) FLAPI PURE;

    /** Returns true if the value is non-NULL and represents a 64-bit floating-point number. */
    bool FLValue_IsDouble(FLValue) FLAPI;

    /** Returns a value coerced to boolean. This will be true unless the value is NULL (undefined),
        null, false, or zero. */
    bool FLValue_AsBool(FLValue) FLAPI PURE;

    /** Returns a value coerced to an integer. True and false are returned as 1 and 0, and
        floating-point numbers are rounded. All other types are returned as 0.
        @warning  Large 64-bit unsigned integers (2^63 and above) will come out wrong. You can
        check for these by calling `FLValueIsUnsigned`. */
    int64_t FLValue_AsInt(FLValue) FLAPI PURE;

    /** Returns a value coerced to an unsigned integer.
        This is the same as `FLValueAsInt` except that it _can't_ handle negative numbers, but
        does correctly return large `uint64_t` values of 2^63 and up. */
    uint64_t FLValue_AsUnsigned(FLValue) FLAPI PURE;

    /** Returns a value coerced to a 32-bit floating point number.
        True and false are returned as 1.0 and 0.0, and integers are converted to float. All other
        types are returned as 0.0.
        @warning  Large integers (outside approximately +/- 2^23) will lose precision due to the
        limitations of IEEE 32-bit float format. */
    float FLValue_AsFloat(FLValue) FLAPI PURE;

    /** Returns a value coerced to a 32-bit floating point number.
        True and false are returned as 1.0 and 0.0, and integers are converted to float. All other
        types are returned as 0.0.
        @warning  Very large integers (outside approximately +/- 2^50) will lose precision due to
        the limitations of IEEE 32-bit float format. */
    double FLValue_AsDouble(FLValue) FLAPI PURE;

    /** Returns the exact contents of a string value, or null for all other types. */
    FLString FLValue_AsString(FLValue) FLAPI PURE;

    /** Converts a value to a timestamp, in milliseconds since Unix epoch, or INT64_MIN on failure.
        - A string is parsed as ISO-8601 (standard JSON date format).
        - A number is interpreted as a timestamp and returned as-is. */
    FLTimestamp FLValue_AsTimestamp(FLValue) FLAPI PURE;

    /** Returns the exact contents of a data value, or null for all other types. */
    FLSlice FLValue_AsData(FLValue) FLAPI PURE;

    /** If a FLValue represents an array, returns it cast to FLArray, else NULL. */
    FLArray FLValue_AsArray(FLValue) FLAPI PURE;

    /** If a FLValue represents a dictionary, returns it as an FLDict, else NULL. */
    FLDict FLValue_AsDict(FLValue) FLAPI PURE;

    /** Returns a string representation of any scalar value. Data values are returned in raw form.
        Arrays and dictionaries don't have a representation and will return NULL. */
    FLStringResult FLValue_ToString(FLValue) FLAPI;

    /** Compares two values for equality. This is a deep recursive comparison. */
    bool FLValue_IsEqual(FLValue v1, FLValue v2) FLAPI PURE;

    /** \name Ref-counting (mutable values only)
         @{ */

    /** If this value is mutable (and thus heap-based) its ref-count is incremented.
        Otherwise, this call does nothing. */
    FLValue FLValue_Retain(FLValue) FLAPI;

    /** If this value is mutable (and thus heap-based) its ref-count is decremented, and if it
        reaches zero the value is freed.
        If the value is not mutable, this call does nothing. */
    void FLValue_Release(FLValue) FLAPI;

    static inline FLArray FLArray_Retain(FLArray v)     {FLValue_Retain((FLValue)v); return v;}
    static inline void FLArray_Release(FLArray v)       {FLValue_Release((FLValue)v);}
    static inline FLDict FLDict_Retain(FLDict v)        {FLValue_Retain((FLValue)v); return v;}
    static inline void FLDict_Release(FLDict v)         {FLValue_Release((FLValue)v);}


    extern const FLValue kFLNullValue;

    /** @} */


    //////// VALUE SLOT


    void FLSlot_SetNull(FLSlot FLNONNULL) FLAPI;             ///< Stores a JSON null into a slot.
    void FLSlot_SetBool(FLSlot FLNONNULL, bool) FLAPI;       ///< Stores a boolean into a slot.
    void FLSlot_SetInt(FLSlot FLNONNULL, int64_t) FLAPI;     ///< Stores an integer into a slot.
    void FLSlot_SetUInt(FLSlot FLNONNULL, uint64_t) FLAPI;   ///< Stores an unsigned integer into a slot.
    void FLSlot_SetFloat(FLSlot FLNONNULL, float) FLAPI;     ///< Stores a float into a slot.
    void FLSlot_SetDouble(FLSlot FLNONNULL, double) FLAPI;   ///< Stores a double into a slot.
    void FLSlot_SetString(FLSlot FLNONNULL, FLString) FLAPI; ///< Stores a string into a slot.
    void FLSlot_SetData(FLSlot FLNONNULL, FLSlice) FLAPI;    ///< Stores a data blob into a slot.
    void FLSlot_SetValue(FLSlot FLNONNULL, FLValue) FLAPI;   ///< Stores an FLValue into a slot.


    //////// ARRAY


    /** @} */
    /** \defgroup FLArray   Arrays
        @{
        FLArray is a "subclass" of FLValue, representing values that are arrays. It's always OK to
        pass an FLArray to a function parameter expecting an FLValue, even though the compiler
        makes you use an explicit type-cast. It's safe to type-cast the other direction, from
        FLValue to FLArray, _only_ if you already know that the value is an array, e.g. by having
        called FLValue_GetType on it. But it's safer to call FLValue_AsArray instead, since it
        will return NULL if the value isn't an array.
     */

    /** Returns the number of items in an array, or 0 if the pointer is NULL. */
    uint32_t FLArray_Count(FLArray) FLAPI PURE;

    /** Returns true if an array is empty (or NULL). Depending on the array's representation,
        this can be faster than `FLArray_Count(a) == 0` */
    bool FLArray_IsEmpty(FLArray) FLAPI PURE;

    /** If the array is mutable, returns it cast to FLMutableArray, else NULL. */
    FLMutableArray FLArray_AsMutable(FLArray) FLAPI PURE;

    /** Returns an value at an array index, or NULL if the index is out of range. */
    FLValue FLArray_Get(FLArray, uint32_t index) FLAPI PURE;

    extern const FLArray kFLEmptyArray;

    /** \name Array iteration
        @{
Iterating an array typically looks like this:

```
FLArrayIterator iter;
FLArrayIterator_Begin(theArray, &iter);
FLValue value;
while (NULL != (value = FLArrayIterator_GetValue(&iter))) {
  // ...
  FLArrayIterator_Next(&iter);
}
```
     */

    /** Opaque array iterator. Declare one on the stack and pass its address to
        `FLArrayIteratorBegin`. */
    typedef struct {
#if !DOXYGEN_PARSING
        void* _private1;
        uint32_t _private2;
        bool _private3;
        void* _private4;
#endif
    } FLArrayIterator;

    /** Initializes a FLArrayIterator struct to iterate over an array.
        Call FLArrayIteratorGetValue to get the first item, then FLArrayIteratorNext. */
    void FLArrayIterator_Begin(FLArray, FLArrayIterator* FLNONNULL) FLAPI;

    /** Returns the current value being iterated over. */
    FLValue FLArrayIterator_GetValue(const FLArrayIterator* FLNONNULL) FLAPI PURE;

    /** Returns a value in the array at the given offset from the current value. */
    FLValue FLArrayIterator_GetValueAt(const FLArrayIterator* FLNONNULL, uint32_t offset) FLAPI PURE;

    /** Returns the number of items remaining to be iterated, including the current one. */
    uint32_t FLArrayIterator_GetCount(const FLArrayIterator* FLNONNULL) FLAPI PURE;

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLArrayIterator_Next(FLArrayIterator* FLNONNULL) FLAPI;

    /** @} */


    //////// MUTABLE ARRAY


    /** \name Mutable Arrays
         @{ */

    typedef enum {
        kFLDefaultCopy        = 0,
        kFLDeepCopy           = 1,
        kFLCopyImmutables     = 2,
        kFLDeepCopyImmutables = (kFLDeepCopy | kFLCopyImmutables),
    } FLCopyFlags;


    /** Creates a new mutable Array that's a copy of the source Array.
        Its initial ref-count is 1, so a call to FLMutableArray_Release will free it.

        Copying an immutable Array is very cheap (only one small allocation) unless the flag
        kFLCopyImmutables is set.

        Copying a mutable Array is cheap if it's a shallow copy, but if `deepCopy` is true,
        nested mutable Arrays and Dicts are also copied, recursively; if kFLCopyImmutables is
        also set, immutable values are also copied.

        If the source Array is NULL, then NULL is returned. */
    FLMutableArray FLArray_MutableCopy(FLArray, FLCopyFlags) FLAPI;

    /** Creates a new empty mutable Array.
        Its initial ref-count is 1, so a call to FLMutableArray_Free will free it.  */
    FLMutableArray FLMutableArray_New(void) FLAPI;

    /** Increments the ref-count of a mutable Array. */
    static inline FLMutableArray FLMutableArray_Retain(FLMutableArray d) {
        return (FLMutableArray)FLValue_Retain((FLValue)d);
    }
    /** Decrements the refcount of (and possibly frees) a mutable Array. */
    static inline void FLMutableArray_Release(FLMutableArray d) {
        FLValue_Release((FLValue)d);
    }

    /** If the Array was created by FLArray_MutableCopy, returns the original source Array. */
    FLArray FLMutableArray_GetSource(FLMutableArray) FLAPI;

    /** Returns true if the Array has been changed from the source it was copied from. */
    bool FLMutableArray_IsChanged(FLMutableArray) FLAPI;

    /** Lets you store a value into a MutableArray, by returning a \ref FLSlot that you can call
        a function like \ref FLSlot_SetInt on. */
    FLSlot FLMutableArray_Set(FLMutableArray FLNONNULL, uint32_t index) FLAPI;

    /** Appends a null value to a MutableArray and returns a \ref FLSlot that you can call
        to store something else in the new value. */
    FLSlot FLMutableArray_Append(FLMutableArray FLNONNULL) FLAPI;

    /** Inserts a contiguous range of JSON `null` values into the array.
        @param array  The array to operate on.
        @param firstIndex  The zero-based index of the first value to be inserted.
        @param count  The number of items to insert. */
    void FLMutableArray_Insert(FLMutableArray array, uint32_t firstIndex, uint32_t count) FLAPI;

    /** Removes contiguous items from the array.
        @param array  The array to operate on.
        @param firstIndex  The zero-based index of the first item to remove.
        @param count  The number of items to remove. */
    void FLMutableArray_Remove(FLMutableArray array, uint32_t firstIndex, uint32_t count) FLAPI;

    /** Changes the size of an array.
        If the new size is larger, the array is padded with JSON `null` values.
        If it's smaller, values are removed from the end. */
    void FLMutableArray_Resize(FLMutableArray array, uint32_t size) FLAPI;

    /** Convenience function for getting an array-valued property in mutable form.
        - If the value for the key is not an array, returns NULL.
        - If the value is a mutable array, returns it.
        - If the value is an immutable array, this function makes a mutable copy, assigns the
          copy as the property value, and returns the copy. */
    FLMutableArray FLMutableArray_GetMutableArray(FLMutableArray, uint32_t index) FLAPI;

    /** Convenience function for getting an array-valued property in mutable form.
        - If the value for the key is not an array, returns NULL.
        - If the value is a mutable array, returns it.
        - If the value is an immutable array, this function makes a mutable copy, assigns the
          copy as the property value, and returns the copy. */
    FLMutableDict FLMutableArray_GetMutableDict(FLMutableArray, uint32_t index) FLAPI;

    /** @} */


    //////// DICT


    /** @} */
    /** \defgroup FLDict   Dictionaries
        @{ */

    /** Returns the number of items in a dictionary, or 0 if the pointer is NULL. */
    uint32_t FLDict_Count(FLDict) FLAPI PURE;

    /** Returns true if a dictionary is empty (or NULL). Depending on the dictionary's
        representation, this can be faster than `FLDict_Count(a) == 0` */
    bool FLDict_IsEmpty(FLDict) FLAPI PURE;

    /** If the dictionary is mutable, returns it cast to FLMutableDict, else NULL. */
    FLMutableDict FLDict_AsMutable(FLDict) FLAPI PURE;

    /** Looks up a key in a dictionary, returning its value.
        Returns NULL if the value is not found or if the dictionary is NULL. */
    FLValue FLDict_Get(FLDict, FLSlice keyString) FLAPI PURE;

    extern const FLDict kFLEmptyDict;

    /** \name Dict iteration
         @{
Iterating a dictionary typically looks like this:

```
FLDictIterator iter;
FLDictIterator_Begin(theDict, &iter);
FLValue value;
while (NULL != (value = FLDictIterator_GetValue(&iter))) {
    FLString key = FLDictIterator_GetKeyString(&iter);
    // ...
    FLDictIterator_Next(&iter);
}
```
     */

    /** Opaque dictionary iterator. Declare one on the stack, and pass its address to
        FLDictIterator_Begin. */
    typedef struct {
#if !DOXYGEN_PARSING
        void* _private1;
        uint32_t _private2;
        bool _private3;
        void* _private4[4];
        int _private5;
#endif
    } FLDictIterator;

    /** Initializes a FLDictIterator struct to iterate over a dictionary.
        Call FLDictIterator_GetKey and FLDictIterator_GetValue to get the first item,
        then FLDictIterator_Next. */
    void FLDictIterator_Begin(FLDict, FLDictIterator* FLNONNULL) FLAPI;

    /** Returns the current key being iterated over. This Value will be a string or an integer. */
    FLValue FLDictIterator_GetKey(const FLDictIterator* FLNONNULL) FLAPI PURE;

    /** Returns the current key's string value. */
    FLString FLDictIterator_GetKeyString(const FLDictIterator* FLNONNULL) FLAPI;

    /** Returns the current value being iterated over. */
    FLValue FLDictIterator_GetValue(const FLDictIterator* FLNONNULL) FLAPI PURE;

    /** Returns the number of items remaining to be iterated, including the current one. */
    uint32_t FLDictIterator_GetCount(const FLDictIterator*  FLNONNULL) FLAPI PURE;

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLDictIterator_Next(FLDictIterator* FLNONNULL) FLAPI;

    /** Cleans up after an iterator. Only needed if (a) the dictionary is a delta, and
        (b) you stop iterating before the end (i.e. before FLDictIterator_Next returns false.) */
    void FLDictIterator_End(FLDictIterator* FLNONNULL) FLAPI;

    /** @} */
    /** \name Optimized Keys
        @{ */

    /** Opaque key for a dictionary. You are responsible for creating space for these; they can
        go on the stack, on the heap, inside other objects, anywhere. 
        Be aware that the lookup operations that use these will write into the struct to store
        "hints" that speed up future searches. */
    typedef struct {
#if !DOXYGEN_PARSING
        FLSlice _private1;
        void* _private2;
        uint32_t _private3, private4;
        bool private5;
#endif
    } FLDictKey;

    /** Initializes an FLDictKey struct with a key string.
        @warning  The input string's memory MUST remain valid for as long as the FLDictKey is in
        use! (The FLDictKey stores a pointer to the string, but does not copy it.)
        @param string  The key string (UTF-8).
        @return  An initialized FLDictKey struct. */
    FLDictKey FLDictKey_Init(FLSlice string) FLAPI;

    /** Returns the string value of the key (which it was initialized with.) */
    FLString FLDictKey_GetString(const FLDictKey * FLNONNULL) FLAPI;

    /** Looks up a key in a dictionary using an FLDictKey. If the key is found, "hint" data will
        be stored inside the FLDictKey that will speed up subsequent lookups. */
    FLValue FLDict_GetWithKey(FLDict, FLDictKey* FLNONNULL) FLAPI;


    //////// MUTABLE DICT


    /** @} */
    /** \name Mutable dictionaries
         @{ */

    /** Creates a new mutable Dict that's a copy of the source Dict.
        Its initial ref-count is 1, so a call to FLMutableDict_Release will free it.

        Copying an immutable Dict is very cheap (only one small allocation.) The `deepCopy` flag
        is ignored.

        Copying a mutable Dict is cheap if it's a shallow copy, but if `deepCopy` is true,
        nested mutable Dicts and Arrays are also copied, recursively.

        If the source dict is NULL, then NULL is returned. */
    FLMutableDict FLDict_MutableCopy(FLDict source, FLCopyFlags) FLAPI;

    /** Creates a new empty mutable Dict.
        Its initial ref-count is 1, so a call to FLMutableDict_Free will free it.  */
    FLMutableDict FLMutableDict_New(void) FLAPI;

    /** Increments the ref-count of a mutable Dict. */
    static inline FLMutableDict FLMutableDict_Retain(FLMutableDict d) {
        return (FLMutableDict)FLValue_Retain((FLValue)d);
    }

    /** Decrements the refcount of (and possibly frees) a mutable Dict. */
    static inline void FLMutableDict_Release(FLMutableDict d) {
        FLValue_Release((FLValue)d);
    }

    /** If the Dict was created by FLDict_MutableCopy, returns the original source Dict. */
    FLDict FLMutableDict_GetSource(FLMutableDict) FLAPI;

    /** Returns true if the Dict has been changed from the source it was copied from. */
    bool FLMutableDict_IsChanged(FLMutableDict) FLAPI;

    /** Returns the Slot storing the key's value, adding a new one if needed (with a null value.)
        To set the value itself, call one of the FLSlot functions, e.g. \ref FLSlot_SetInt. */
    FLSlot FLMutableDict_Set(FLMutableDict FL_NONNULL, FLString key) FLAPI;

    /** Removes the value for a key. */
    void FLMutableDict_Remove(FLMutableDict, FLString key) FLAPI;

    /** Removes all keys and values. */
    void FLMutableDict_RemoveAll(FLMutableDict) FLAPI;

    /** Convenience function for getting an array-valued property in mutable form.
        - If the value for the key is not an array, returns NULL.
        - If the value is a mutable array, returns it.
        - If the value is an immutable array, this function makes a mutable copy, assigns the
          copy as the property value, and returns the copy. */
    FLMutableArray FLMutableDict_GetMutableArray(FLMutableDict, FLString key) FLAPI;

    /** Convenience function for getting a dict-valued property in mutable form.
        - If the value for the key is not a dict, returns NULL.
        - If the value is a mutable dict, returns it.
        - If the value is an immutable dict, this function makes a mutable copy, assigns the
          copy as the property value, and returns the copy. */
    FLMutableDict FLMutableDict_GetMutableDict(FLMutableDict, FLString key) FLAPI;

    /** @} */


    //////// DEEP ITERATOR


    /** @} */
    /** \defgroup FLDeepIterator   Deep Iterator
        @{
        A deep iterator traverses every value contained in a dictionary, in depth-first order.
        You can skip any nested collection by calling FLDeepIterator_SkipChildren. */

#ifndef FL_IMPL
    typedef struct _FLDeepIterator* FLDeepIterator; ///< A reference to a deep iterator.
#endif

    /** Creates a FLDeepIterator to iterate over a dictionary.
        Call FLDeepIterator_GetKey and FLDeepIterator_GetValue to get the first item,
        then FLDeepIterator_Next. */
    FLDeepIterator FLDeepIterator_New(FLValue) FLAPI;

    void FLDeepIterator_Free(FLDeepIterator) FLAPI;

    /** Returns the current value being iterated over. or NULL at the end of iteration. */
    FLValue FLDeepIterator_GetValue(FLDeepIterator FLNONNULL) FLAPI;

    /** Returns the key of the current value, or an empty slice if not in a dictionary. */
    FLSlice FLDeepIterator_GetKey(FLDeepIterator FLNONNULL) FLAPI;

    /** Returns the array index of the current value, or 0 if not in an array. */
    uint32_t FLDeepIterator_GetIndex(FLDeepIterator FLNONNULL) FLAPI;

    /** Returns the current depth in the hierarchy, starting at 1 for the top-level children. */
    size_t FLDeepIterator_GetDepth(FLDeepIterator FLNONNULL) FLAPI;

    /** Tells the iterator to skip the children of the current value. */
    void FLDeepIterator_SkipChildren(FLDeepIterator FLNONNULL) FLAPI;

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLDeepIterator_Next(FLDeepIterator FLNONNULL) FLAPI;

    typedef struct {
        FLSlice key;        ///< Dict key, or kFLSliceNull if none
        uint32_t index;     ///< Array index, only if there's no key
    } FLPathComponent;

    /** Returns the path as an array of FLPathComponents. */
    void FLDeepIterator_GetPath(FLDeepIterator FLNONNULL,
                                FLPathComponent* * FLNONNULL outPath,
                                size_t* FLNONNULL outDepth) FLAPI;

    /** Returns the current path in JavaScript format. */
    FLSliceResult FLDeepIterator_GetPathString(FLDeepIterator FLNONNULL) FLAPI;

    /** Returns the current path in JSONPointer format (RFC 6901). */
    FLSliceResult FLDeepIterator_GetJSONPointer(FLDeepIterator FLNONNULL) FLAPI;


    //////// PATH


    /** @} */
    /** \defgroup FLKeyPath   Paths
        @{
     An FLKeyPath Describes a location in a Fleece object tree, as a path from the root that follows
     dictionary properties and array elements.
     It's similar to a JSONPointer or an Objective-C KeyPath, but simpler (so far.)
     The path is compiled into an efficient form that can be traversed quickly.

     It looks like `foo.bar[2][-3].baz` -- that is, properties prefixed with a `.`, and array
     indexes in brackets. (Negative indexes count from the end of the array.)

     A leading JSONPath-like `$.` is allowed but ignored.

     A '\' can be used to escape a special character ('.', '[' or '$') at the start of a
     property name (but not yet in the middle of a name.)
     */

#ifndef FL_IMPL
    typedef struct _FLKeyPath*     FLKeyPath;       ///< A reference to a key path.
#endif

    /** Creates a new FLKeyPath object by compiling a path specifier string. */
    FLKeyPath FLKeyPath_New(FLSlice specifier, FLError *error) FLAPI;

    /** Frees a compiled FLKeyPath object. (It's ok to pass NULL.) */
    void FLKeyPath_Free(FLKeyPath) FLAPI;

    /** Evaluates a compiled key-path for a given Fleece root object. */
    FLValue FLKeyPath_Eval(FLKeyPath FLNONNULL, FLValue root FLNONNULL) FLAPI;

    /** Evaluates a key-path from a specifier string, for a given Fleece root object.
        If you only need to evaluate the path once, this is a bit faster than creating an
        FLKeyPath object, evaluating, then freeing it. */
    FLValue FLKeyPath_EvalOnce(FLSlice specifier, FLValue root FLNONNULL, FLError *error) FLAPI;


    //////// SHARED KEYS


    /** @} */
    /** \defgroup FLSharedKeys   Shared Keys
        @{ */

    FLSharedKeys FLSharedKeys_Create(void) FLAPI;
    FLSharedKeys FLSharedKeys_Retain(FLSharedKeys) FLAPI;
    void FLSharedKeys_Release(FLSharedKeys) FLAPI;
    FLSharedKeys FLSharedKeys_CreateFromStateData(FLSlice) FLAPI;
    FLSliceResult FLSharedKeys_GetStateData(FLSharedKeys FLNONNULL) FLAPI;
    int FLSharedKeys_Encode(FLSharedKeys FLNONNULL, FLString, bool add) FLAPI;
    FLString FLSharedKeys_Decode(FLSharedKeys FLNONNULL, int key) FLAPI;
    unsigned FLSharedKeys_Count(FLSharedKeys FLNONNULL) FLAPI;


    //////// ENCODER


    /** @} */
    /** \defgroup FLEncoder   Encoder
        @{
        An FLEncoder generates encoded Fleece or JSON data. It's sort of a structured output stream,
        with nesting. There are functions for writing every type of scalar value, and for beginning
        and ending collections. To write a collection you begin it, write its values, then end it.
        (Of course a value in a collection can itself be another collection.) When writing a
        dictionary, you have to call writeKey before writing each value.
     */

#ifndef FL_IMPL
    typedef struct _FLEncoder*     FLEncoder;       ///< A reference to an encoder.
#endif

    /** \name Setup and configuration
         @{ */

    /** Output formats a FLEncoder can generate. */
    typedef enum {
        kFLEncodeFleece,    ///< Fleece encoding
        kFLEncodeJSON,      ///< JSON encoding
        kFLEncodeJSON5      ///< [JSON5](http://json5.org), an extension of JSON with a more readable syntax
    } FLEncoderFormat;


    /** Creates a new encoder, for generating Fleece data. Call FLEncoder_Free when done. */
    FLEncoder FLEncoder_New(void) FLAPI;

    /** Creates a new encoder, allowing some options to be customized.
        @param format  The output format to generate (Fleece, JSON, or JSON5.)
        @param reserveSize  The number of bytes to preallocate for the output. (Default is 256)
        @param uniqueStrings  (Fleece only) If true, string values that appear multiple times will be written
            as a single shared value. This saves space but makes encoding slightly slower.
            You should only turn this off if you know you're going to be writing large numbers
            of non-repeated strings. (Default is true) */
    FLEncoder FLEncoder_NewWithOptions(FLEncoderFormat format,
                                       size_t reserveSize,
                                       bool uniqueStrings) FLAPI;

    /** Creates a new Fleece encoder that writes to a file, not to memory. */
    FLEncoder FLEncoder_NewWritingToFile(FILE* FLNONNULL, bool uniqueStrings) FLAPI;

    /** Frees the space used by an encoder. */
    void FLEncoder_Free(FLEncoder) FLAPI;

    /** Tells the encoder to use a shared-keys mapping when encoding dictionary keys. */
    void FLEncoder_SetSharedKeys(FLEncoder FLNONNULL, FLSharedKeys) FLAPI;

    /** Associates an arbitrary user-defined value with the encoder. */
    void FLEncoder_SetExtraInfo(FLEncoder FLNONNULL, void *info) FLAPI;

    /** Returns the user-defined value associated with the encoder; NULL by default. */
    void* FLEncoder_GetExtraInfo(FLEncoder FLNONNULL) FLAPI;


    /** Tells the encoder to logically append to the given Fleece document, rather than making a
        standalone document. Any calls to FLEncoder_WriteValue() where the value points inside the
        base data will write a pointer back to the original value.
        The resulting data returned by FLEncoder_FinishDoc() will *NOT* be standalone; it can only
        be used by first appending it to the base data.
        @param e  The FLEncoder affected.
        @param base  The base document to create an amendment of.
        @param reuseStrings  If true, then writing a string that already exists in the base will
                    just create a pointer back to the original. But the encoder has to scan the
                    base for strings first.
        @param externPointers  If true, pointers into the base will be marked with the `extern`
                    flag. This allows them to be resolved using the `FLResolver_Begin` function,
                    so that when the delta is used the base document can be anywhere in memory,
                    not just immediately preceding the delta document. */
    void FLEncoder_Amend(FLEncoder e FLNONNULL, FLSlice base,
                         bool reuseStrings, bool externPointers) FLAPI;

    /** Returns the `base` value passed to FLEncoder_Amend. */
    FLSlice FLEncoder_GetBase(FLEncoder FLNONNULL) FLAPI;

    /** Tells the encoder not to write the two-byte Fleece trailer at the end of the data.
        This is only useful for certain special purposes. */
    void FLEncoder_SuppressTrailer(FLEncoder FLNONNULL) FLAPI;

    /** Resets the state of an encoder without freeing it. It can then be reused to encode
        another value. */
    void FLEncoder_Reset(FLEncoder FLNONNULL) FLAPI;

    /** Returns the number of bytes encoded so far. */
    size_t FLEncoder_BytesWritten(FLEncoder FLNONNULL) FLAPI;

    /** Returns the byte offset in the encoded data where the next value will be written.
        (Due to internal buffering, this is not the same as FLEncoder_BytesWritten.) */
    size_t FLEncoder_GetNextWritePos(FLEncoder FLNONNULL) FLAPI;

    /** @} */
    /** \name Writing to the encoder
         @{
        @note The functions that write to the encoder do not return error codes, just a 'false'
        result on error. The actual error is attached to the encoder and can be accessed by calling
        FLEncoder_GetError or FLEncoder_End.

        After an error occurs, the encoder will ignore all subsequent writes. */

    /** Writes a `null` value to an encoder. (This is an explicitly-stored null, like the JSON
        `null`, not the "undefined" value represented by a NULL FLValue pointer.) */
    bool FLEncoder_WriteNull(FLEncoder FLNONNULL) FLAPI;

    /** Writes an `undefined` value to an encoder. (Its value when read will not be a `NULL`
        pointer, but it can be recognized by `FLValue_GetType` returning `kFLUndefined`.)
        @note The only real use for writing undefined values is to represent "holes" in an array.
        An undefined dictionary value should be written simply by skipping the key and value. */
    bool FLEncoder_WriteUndefined(FLEncoder FLNONNULL) FLAPI;

    /** Writes a boolean value (true or false) to an encoder. */
    bool FLEncoder_WriteBool(FLEncoder FLNONNULL, bool) FLAPI;

    /** Writes an integer to an encoder. The parameter is typed as `int64_t` but you can pass any
        integral type (signed or unsigned) except for huge `uint64_t`s.
        The number will be written in a compact form that uses only as many bytes as necessary. */
    bool FLEncoder_WriteInt(FLEncoder FLNONNULL, int64_t) FLAPI;

    /** Writes an unsigned integer to an encoder.
        @note This function is only really necessary for huge
        64-bit integers greater than or equal to 2^63, which can't be represented as int64_t. */
    bool FLEncoder_WriteUInt(FLEncoder FLNONNULL, uint64_t) FLAPI;

    /** Writes a 32-bit floating point number to an encoder.
        @note As an implementation detail, if the number has no fractional part and can be
        represented exactly as an integer, it'll be encoded as an integer to save space. This is
        transparent to the reader, since if it requests the value as a float it'll be returned
        as floating-point. */
    bool FLEncoder_WriteFloat(FLEncoder FLNONNULL, float) FLAPI;

    /** Writes a 64-bit floating point number to an encoder.
        @note As an implementation detail, the number may be encoded as a 32-bit float or even
        as an integer, if this can be done without losing precision. For example, 123.0 will be
        written as an integer, and 123.75 as a float.) */
    bool FLEncoder_WriteDouble(FLEncoder FLNONNULL, double) FLAPI;

    /** Writes a string to an encoder. The string must be UTF-8-encoded and must not contain any
        zero bytes.
        @warning Do _not_ use this to write a dictionary key; use FLEncoder_WriteKey instead. */
    bool FLEncoder_WriteString(FLEncoder FLNONNULL, FLString) FLAPI;

    /** Writes a timestamp to an encoder, as an ISO-8601 date string.
        @note Since neither Fleece nor JSON have a 'Date' type, the encoded string has no
        metadata that distinguishes it as a date. It's just a string.)
        @param encoder  The encoder to write to.
        @param ts  The timestamp (milliseconds since Unix epoch 1-1-1970).
        @param asUTC  If true, date is written in UTC (GMT); if false, with the local timezone.
        @return  True on success, false on error. */
    bool FLEncoder_WriteDateString(FLEncoder FLNONNULL encoder, FLTimestamp ts, bool asUTC) FLAPI;

    /** Writes a binary data value (a blob) to an encoder. This can contain absolutely anything
        including null bytes.
        If the encoder is generating JSON, the blob will be written as a base64-encoded string. */
    bool FLEncoder_WriteData(FLEncoder FLNONNULL, FLSlice) FLAPI;

    /** Writes raw data directly to the encoded output.
        (This is not the same as FLEncoder_WriteData, which safely encodes a blob.)
        @warning **Do not call this** unless you really know what you're doing ...
        it's quite unsafe, and only used for certain advanced purposes. */
    bool FLEncoder_WriteRaw(FLEncoder FLNONNULL, FLSlice) FLAPI;


    /** Begins writing an array value to an encoder. This pushes a new state where each
        subsequent value written becomes an array item, until FLEncoder_EndArray is called.
        @param reserveCount  Number of array elements to reserve space for. If you know the size
            of the array, providing it here speeds up encoding slightly. If you don't know,
            just use zero. */
    bool FLEncoder_BeginArray(FLEncoder FLNONNULL, size_t reserveCount) FLAPI;

    /** Ends writing an array value; pops back the previous encoding state. */
    bool FLEncoder_EndArray(FLEncoder FLNONNULL) FLAPI;


    /** Begins writing a dictionary value to an encoder. This pushes a new state where each
        subsequent key and value written are added to the dictionary, until FLEncoder_EndDict is
        called.
        Before adding each value, you must call FLEncoder_WriteKey (_not_ FLEncoder_WriteString!),
        to write the dictionary key.
        @param reserveCount  Number of dictionary items to reserve space for. If you know the size
            of the dictionary, providing it here speeds up encoding slightly. If you don't know,
            just use zero. */
    bool FLEncoder_BeginDict(FLEncoder FLNONNULL, size_t reserveCount) FLAPI;

    /** Specifies the key for the next value to be written to the current dictionary. */
    bool FLEncoder_WriteKey(FLEncoder FLNONNULL, FLString) FLAPI;

    /** Specifies the key for the next value to be written to the current dictionary.
        The key is given as a Value, which must be a string or integer. */
    bool FLEncoder_WriteKeyValue(FLEncoder FLNONNULL, FLValue FLNONNULL) FLAPI;

    /** Ends writing a dictionary value; pops back the previous encoding state. */
    bool FLEncoder_EndDict(FLEncoder FLNONNULL) FLAPI;


    /** Writes a Fleece Value to an Encoder. */
    bool FLEncoder_WriteValue(FLEncoder FLNONNULL, FLValue FLNONNULL) FLAPI;


    /** Parses JSON data and writes the object(s) to the encoder. (This acts as a single write,
        like WriteInt; it's just that the value written is likely to be an entire dictionary of
        array.) */
    bool FLEncoder_ConvertJSON(FLEncoder FLNONNULL, FLSlice json) FLAPI;

    /** @} */
    /** \name Finishing up
         @{ */

    /** Finishes encoding the current item, and returns its offset in the output data. */
    size_t FLEncoder_FinishItem(FLEncoder FLNONNULL) FLAPI;

    /** Ends encoding; if there has been no error, it returns the encoded Fleece data packaged in
        an FLDoc. (This function does not support JSON encoding.)
        This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next. */
    FLDoc FLEncoder_FinishDoc(FLEncoder FLNONNULL, FLError*) FLAPI;

    /** Ends encoding; if there has been no error, it returns the encoded data, else null.
        This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next. */
    FLSliceResult FLEncoder_Finish(FLEncoder e, FLError *outError) FLAPI;

    /** @} */
    /** \name Error handling
         @{ */

    /** Returns the error code of an encoder, or NoError (0) if there's no error. */
    FLError FLEncoder_GetError(FLEncoder FLNONNULL) FLAPI;

    /** Returns the error message of an encoder, or NULL if there's no error. */
    const char* FLEncoder_GetErrorMessage(FLEncoder FLNONNULL) FLAPI;

    /** @} */
    /** @} */


    //////// JSON DELTA COMPRESSION


    /** @} */
    /** \defgroup delta   Delta Compression
     @{
        These functions implement a fairly-efficient "delta" encoding that encapsulates the changes
        needed to transform one Fleece value into another. The delta is expressed in JSON form.

        A delta can be stored or transmitted
        as an efficient way to produce the second value, when the first is already present. Deltas
        are frequently used in version-control systems and efficient network protocols.
     */

    /** Returns JSON that encodes the changes to turn the value `old` into `nuu`.
        (The format is documented in Fleece.md, but you should treat it as a black box.)
        @param old  A value that's typically the old/original state of some data.
        @param nuu  A value that's typically the new/changed state of the `old` data.
        @return  JSON data representing the changes from `old` to `nuu`, or NULL on
                    (extremely unlikely) failure. */
    FLSliceResult FLCreateJSONDelta(FLValue old, FLValue nuu) FLAPI;

    /** Writes JSON that describes the changes to turn the value `old` into `nuu`.
        (The format is documented in Fleece.md, but you should treat it as a black box.)
        @param old  A value that's typically the old/original state of some data.
        @param nuu  A value that's typically the new/changed state of the `old` data.
        @param jsonEncoder  An encoder to write the JSON to. Must have been created using
                `FLEncoder_NewWithOptions`, with JSON or JSON5 format.
        @return  True on success, false on (extremely unlikely) failure. */
    bool FLEncodeJSONDelta(FLValue old, FLValue nuu, FLEncoder FLNONNULL jsonEncoder) FLAPI;


    /** Applies the JSON data created by `CreateJSONDelta` to the value `old`, which must be equal
        to the `old` value originally passed to `FLCreateJSONDelta`, and returns a Fleece document
        equal to the original `nuu` value.
        @param old  A value that's typically the old/original state of some data. This must be
                    equal to the `old` value used when creating the `jsonDelta`.
        @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
        @param error  On failure, error information will be stored where this points, if non-null.
        @return  The corresponding `nuu` value, encoded as Fleece, or null if an error occurred. */
    FLSliceResult FLApplyJSONDelta(FLValue old,
                                   FLSlice jsonDelta,
                                   FLError *error) FLAPI;

    /** Applies the (parsed) JSON data created by `CreateJSONDelta` to the value `old`, which must be
        equal to the `old` value originally passed to `FLCreateJSONDelta`, and writes the corresponding
        `nuu` value to the encoder.
        @param old  A value that's typically the old/original state of some data. This must be
                    equal to the `old` value used when creating the `jsonDelta`.
        @param jsonDelta  A JSON-encoded delta created by `FLCreateJSONDelta` or `FLEncodeJSONDelta`.
        @param encoder  A Fleece encoder to write the decoded `nuu` value to. (JSON encoding is not
                    supported.)
        @return  True on success, false on error; call `FLEncoder_GetError` for details. */
    bool FLEncodeApplyingJSONDelta(FLValue old,
                                   FLSlice jsonDelta,
                                   FLEncoder encoder) FLAPI;

    
    /** @} */

#ifdef __cplusplus
}
#endif


#ifdef __OBJC__
// When compiling as Objective-C, include CoreFoundation / Objective-C utilities:
#include "Fleece+CoreFoundation.h"
#endif

#endif // _FLEECE_H
